# The main menu is shown at game start or pause on an OQ_UI2DCanvas
# some logic is in the BeepSaber_Game.gd to set the correct state
#
# This file also contains the logic to load a beatmap in the format that
# normal Beat Saber uses. So you can load here custom beat saber songs too
extends Panel

# we need the main game class here to trigger game start/restart/continue
var _beepsaber = null;

func initialize(beepsaber_game):
	_beepsaber = beepsaber_game;


func set_mode_game_start():
	$Play_Button.visible = true;


func set_mode_continue():
	$Play_Button.visible = false;


var path = "res://game/data/maps/";
var dlpath = str(OS.get_system_dir(3))+"/";
var bspath = "/sdcard/BeepSaber/";
#var bspath = "user://BeepSaber/";
export(NodePath) var keyboard;

var _playlists

var PlaylistButton = preload("res://game/PlaylistButton.tscn")

func _load_playlists():
	var Playlists = $PlaylistMenu/Playlists
	
	_playlists = [];
	
	#copy sample songs to main playlist folder on first run
	var file = File.new()
	var config_path = "user://config.dat"
	if not file.file_exists(config_path):
		var dir = Directory.new()
		var copy = Directory.new()
		dir.make_dir_recursive(bspath+"Songs/")
		dir.open(path+"Songs/")
		dir.list_dir_begin(true,true)
		var file_name = dir.get_next()
		while file_name != "":
			if dir.current_is_dir():
				var new_dir = path+"Songs/"+file_name;
				copy.make_dir_recursive(bspath+"Songs/"+file_name)
				copy.open(new_dir)
				copy.list_dir_begin(true,true)
				var copy_file_name = copy.get_next()
				while copy_file_name != "":
					var copy_new_dir = new_dir+"/"+copy_file_name;
					print(copy_new_dir)
					dir.copy(copy_new_dir,bspath+"Songs/"+file_name+"/"+copy_file_name)
					copy_file_name = copy.get_next();
			file_name = dir.get_next();
	
	_autogen_playlists(bspath+"Songs/", "BeepSaber/Songs/");
	
	if (!_playlists):
		vr.log_error("No songs found in " + bspath);
		for b in $SongsMenu/Songs.get_children():
			b.queue_free()
		return false;
	
	
	if (_playlists.size() == 0):
		_set_cur_playlist([])
	else:
		_set_cur_playlist(_playlists[0])
		
		
func _autogen_playlists(seek_path,name):
	var songlist = [];
	var dir = Directory.new();
	var err = dir.open(seek_path);
	if err == OK:
		#$Label.text+="\nOpen:"+path;
		dir.list_dir_begin(true,true);
		var file_name = dir.get_next()
		while file_name != "":
			if dir.current_is_dir(): #or file_name.ends_with(".zip"):
				var new_dir = seek_path+file_name+"/";
				var song = _load_song_info(new_dir);
				if song:
					var source = seek_path.substr(bspath.length()+"Songs".length());
					songlist.append({"id":file_name,"source":source.substr(0,source.length()-1)});
				else:
					_autogen_playlists(new_dir,file_name);
			file_name = dir.get_next();
		if songlist:
			_playlists.append({"Name":name,"Description":"Autogenerated","Songs":songlist});

var SongButton = preload("res://game/SongButton.tscn")

func _set_cur_playlist(pl):
	
	var Songs = $SongsMenu/Songs
	
	for song in Songs.get_children():
		song.queue_free()
	
	var info
	var to_select = true
	if pl.has("Songs"):
		for dat in pl["Songs"]:
			to_select = _wire_song_dat(dat,to_select);

func _wire_song_dat(dat, to_select):
	var Songs = $SongsMenu/Songs
	var newSongButton = SongButton.instance();
	newSongButton.id = dat;
	newSongButton.info = _load_song_info(_song_path(dat));
	newSongButton.connect("pressed_id", self, "_select_song");
	Songs.add_child(newSongButton)
	if newSongButton.info and to_select:
		_select_song(dat)
		to_select = false
	return to_select;
	
func _song_path(dat):
	if dat.has("source"): #if a source is specified then it's either in the applicable downloads folder or a subfolder
		if dat.source:
			return bspath +"Songs/" + dat.source + "/" + dat.id + "/";
		else:
			#windows can handle // in a path but android can't
			return bspath +"Songs/" + dat.id + "/";
	else:
		return path + "Songs/" + dat.id + "/";
	
func _load_song_info(load_path):
	var dir = Directory.new();
	var map_info = vr.load_json_file(load_path + "Info.dat");
	if (!map_info):
		map_info = vr.load_json_file(load_path + "info.dat");
		#because android is case sensitive and some maps have it lowercase, some not
		if (!map_info):
			#vr.log_error("Invalid info.dat found in " + load_path);
			return false;
		
	if (map_info._difficultyBeatmapSets.size() == 0):
		vr.log_error("No _difficultyBeatmapSets in info.dat");
		return false;
	map_info._path=load_path
	return map_info;
	
func _load_cover(cover_path, filename):
	if not (filename.ends_with(".jpg") or filename.ends_with(".png")):
		print("wrong format");
		return;
	if (cover_path.begins_with("res://")):
		return load(cover_path+filename)
	else:
		var tex = ImageTexture.new();
		var img = Image.new();
		#var uncompressed = vr.try_zipdata(cover_path, filename);
		#if uncompressed: #in case it's in an archive (too slow on Quest though)
		#	if filename.ends_with(".jpg"):
		#		img.load_jpg_from_buffer(uncompressed);
		#	elif filename.ends_with(".png"):
		#		img.load_png_from_buffer(uncompressed);
		#else:
		img.load(cover_path+filename);
		tex.create_from_image(img); #instead of loading from resources, load form file
		return tex;	


# a loaded beat map will have an info dictionary; this is a global variable here
# to later extend it to load different maps
var _map_id = null;
var _map_info = null;
var _map_path = null;

var DifficultyButton = preload("res://game/DifficultyButton.tscn")


func _select_song(id):
	_map_id = id;
	_map_path = _song_path(id);
	$Delete_Button.disabled = false;
	_map_info = _load_song_info(_map_path);
	$SongInfo_Label.text = """Song Author: %s
	Song Title: %s
	Beatmap Author: %s""" %[_map_info._songAuthorName, _map_info._songName, _map_info._levelAuthorName]

	$cover.texture = _load_cover(_song_path(id), _map_info._coverImageFilename);
	
	var Songs = $SongsMenu/Songs
	for song in Songs.get_children():
		if song.id == id:
			song.modulate = Color(1, 0.5, 0.5)
		else:
			song.modulate = Color(1, 1, 1)
	
	var Difficulties = $DifficultyMenu/Playlists
	for difficulty in Difficulties.get_children():
		difficulty.queue_free()
	for ii_dif in range(_map_info._difficultyBeatmapSets[0]._difficultyBeatmaps.size()):
		var newDifficultyButton = DifficultyButton.instance()
		newDifficultyButton.id = ii_dif
		var BMPS = _map_info._difficultyBeatmapSets[0]._difficultyBeatmaps
		newDifficultyButton.Name = _map_info._difficultyBeatmapSets[0]._difficultyBeatmaps[ii_dif]._difficulty
		newDifficultyButton.connect("pressed_id", self, "_select_difficulty")
		Difficulties.add_child(newDifficultyButton)
	
	_select_difficulty(0)


var _map_difficulty = 0
var _map_difficulty_name = ""
var _map_difficulty_noteJumpMovementSpeed = 9.0

func _select_difficulty(id):
	_map_difficulty = id
	var Difficulties = $DifficultyMenu/Playlists
	for difficulty in Difficulties.get_children():
		difficulty.modulate = Color(1, 1, 1)
	Difficulties.get_child(id).modulate = Color(1, 0.5, 0.5)
	_map_difficulty_name = Difficulties.get_child(id).text


func _load_map_and_start():
	if (_map_info == null): return;
		
	var set0 = _map_info._difficultyBeatmapSets[0];
	if (set0._difficultyBeatmaps.size() == 0):
		vr.log_error("No _difficultyBeatmaps in set");
		return false;
		
	var map_info = set0._difficultyBeatmaps[_map_difficulty];
	var map_filename = _map_info._path + map_info._beatmapFilename;
	var map_data = vr.load_json_file(map_filename);
	_map_difficulty_noteJumpMovementSpeed = set0._difficultyBeatmaps[_map_difficulty]["_noteJumpMovementSpeed"];
	
	if (map_data == null):
		vr.log_error("Could not read map data from " + map_filename);
	
	#print(info);

	_beepsaber.start_map(_map_info, map_data);
	
	return true;

func _on_Delete_Button_button_up():
	if $Delete_Button.text != "Sure?":
		$Delete_Button.text = "Sure?";
		yield(get_tree().create_timer(5),"timeout");
		$Delete_Button.text = "Delete";
	else:
		$Delete_Button.text = "Delete";
		_delete_map();
	
func _delete_map():
	if _map_path:
		var dir = Directory.new();
		if dir.open(_map_path) == 0:
			dir.list_dir_begin();
			var current_file = dir.get_next();
			while current_file != "":
				dir.remove(_map_path+current_file);
				current_file = dir.get_next();
			dir.remove(_map_path);
			vr.log_info(_map_path+" Removed");
			_map_path = null;
			$Delete_Button.disabled = true;
		else:
			vr.log_info("Error removing song "+_map_path);
		_on_LoadPlaylists_Button_pressed()


func _ready():
	if OS.get_name() != "Android":
		bspath = dlpath+"BeepSaber/";
	vr.log_info("BeepSaber search path is " + bspath);
	
	keyboard = get_node(keyboard);
	keyboard.connect("text_input_enter",self,"_text_input_enter")
	keyboard.connect("text_input_cancel",self,"_text_input_cancel")

	_load_playlists();
	
	yield(get_tree(),"physics_frame")
	keyboard._text_edit.connect("text_changed",self,"_text_input_changed")
	keyboard._text_edit.connect("focus_exited",self,"_text_input_enter")


func _on_Play_Button_pressed():
	_load_map_and_start();


func _on_Exit_Button_pressed():
	get_tree().quit()


func _on_Restart_Button_pressed():
	_beepsaber.restart_map();


func _on_Continue_Button_pressed():
	_beepsaber.continue_map();

func _on_Stop_Button_pressed():
	set_mode_game_start();


const READ_PERMISSION = "android.permission.READ_EXTERNAL_STORAGE"

func is_in_array(arr : Array, val):
	for e in arr:
		if (e == val): return true;
	return false;
	
func _check_required_permissions():
	if (!vr.inVR): return true; # desktop is always allowed
	
	var permissions = OS.get_granted_permissions()
	var read_storage_permission = is_in_array(permissions, READ_PERMISSION)
	
	vr.log_info(str(permissions));
	
	if !(read_storage_permission):
		return false;

	return true;

func _check_and_request_permission():
	vr.log_info("Checking permissions")

	if !(_check_required_permissions()):
		vr.log_info("Requesting permissions")
		OS.request_permissions()
		return false;
	else:
		return true;



# Note (19.10.2020): downloading of unknown songs is currently disabled
#                    as this will need special handling also on the quest
#
#var download_id = ""
#func _download_song_id(id):
#	download_id = id
#	$HTTPRequest.request("https://beatsaver.com/api/download/key/"+id)
#	return null

#func extract_file(zip_file, fileName, destination):
#	var gdunzip = load('res://addons/gdunzip/gdunzip.gd').new()
#	var loaded = gdunzip.load(zip_file)
#	var file = File.new()
#	var uncompressed = gdunzip.uncompress(fileName)
#	file.open(destination+"/"+fileName, File.WRITE)
#	file.store_buffer(uncompressed)
#	file.close()
#	print("DECOMPRESSED: "+fileName)
#
#
#func unzip(zip_file, destination):
#	var gdunzip = load('res://addons/gdunzip/gdunzip.gd').new()
#	var loaded = gdunzip.load(zip_file)
#	if !loaded:
#		return false
#	for f in gdunzip.files:
#		# extract_file(zip_file, f, destination) # NOT WORKING PROPERLY
#		print(f)
#
#
#func _on_HTTPRequest_request_completed(result, response_code, headers, body):
#	var directory = Directory.new()
#	if response_code == 200:
#		print("Downloaded song: "+download_id)
#		directory.make_dir("res://game/data/maps/Songs/"+download_id)
#		var file = File.new()
#		file.open("res://game/data/maps/Songs/"+download_id+"/temp.zip", File.WRITE)
#		file.store_buffer(body)
#		file.close()
#		unzip("res://game/data/maps/Songs/"+download_id+"/temp.zip", "res://game/data/maps/Songs/"+download_id)
#	else:
#		print("Failed to download song: "+download_id)


func _on_LoadPlaylists_Button_pressed():
	# Note: this call is non-blocking; so a user has to click again after
	#       granting the permissions; we need to find a solutio for this
	#       maybe polling after the button press?
	if (_check_and_request_permission()):
		_load_playlists();


func _on_Search_Button_button_up():
	keyboard.visible=true
	keyboard._text_edit.grab_focus();

func _text_input_enter(text):
	keyboard.visible=false
func _text_input_cancel():
	keyboard.visible=false
	_clean_search()
	
func _text_input_changed():
	var text = keyboard._text_edit.text
	$Search_Button/Label.text = text
	if text == "":
		_clean_search()
		return
	var most_similar = 0.0
	var results = false
	for song in $SongsMenu/Songs.get_children():
		var similarity = song.text.similarity(text)
		song.visible = similarity != 0
		if song.visible:
			if similarity > most_similar:
				most_similar = similarity
				$SongsMenu/Songs.move_child(song,0)
			results = true
	if not results:
		_clean_search()
	
func _clean_search():
	for song in $SongsMenu/Songs.get_children():
		song.visible = true
	$Search_Button/Label.text = ""
	


